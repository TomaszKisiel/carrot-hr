{"ast":null,"code":"// Returns the name of the day based on a date\nconst days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\nexport const getDayName = date => {\n  let dt = new Date(date);\n  return days[dt.getDay()];\n};\nconst days_PL = [\"ND\", \"PN\", \"WT\", \"ŚR\", \"CZ\", \"PT\", \"SB\"];\nexport const getPolishDayName = date => {\n  let dt = new Date(date);\n  return days_PL[dt.getDay()];\n};\nexport const timeValidator = time => {\n  let reg = /^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/;\n  return reg.test(time);\n};\nexport const shiftValidator = shift => {\n  let shifts = [\"1\", \"2\", \"3\", \"W\", \"PN\", \"WT\", \"ŚR\", \"CZ\", \"PT\", \"SB\", \"ND\"];\n  return shifts.includes(shift);\n}; // Working same as Array.prototype.filter, but it's cut filtered elements from orginal array if they satisfy condition in predication\n\nexport const select = (arr, predicate) => {\n  if (typeof predicate != \"function\") throw new TypeError();\n  var selected = arr.filter(x => {\n    return predicate.call(arr[0], x, arr);\n  });\n\n  for (const val of selected) {\n    let i = arr.indexOf(val);\n    arr.splice(i, 1);\n  }\n\n  return selected;\n}; // Chunks the array into parts\n\nexport const chunk = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (v, i) => arr.slice(i * size, i * size + size));\nexport const wodge = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (v, i) => arr.slice(i * size, i * size + size + 1)); // Copies arrays without any references\n\nexport const duplicate = arr => {\n  return JSON.parse(JSON.stringify(arr));\n};","map":{"version":3,"sources":["/home/tomek/social-media/carrot-studio/CarrotHR/src/Components/Helpers.js"],"names":["days","getDayName","date","dt","Date","getDay","days_PL","getPolishDayName","timeValidator","time","reg","test","shiftValidator","shift","shifts","includes","select","arr","predicate","TypeError","selected","filter","x","call","val","i","indexOf","splice","chunk","size","Array","from","length","Math","ceil","v","slice","wodge","duplicate","JSON","parse","stringify"],"mappings":"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","sourcesContent":["// Returns the name of the day based on a date\nconst days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\nexport const getDayName = (date) => {\n\tlet dt = new Date(date);\n\treturn days[dt.getDay()];\n}\n\nconst days_PL = [\"ND\", \"PN\", \"WT\", \"ŚR\", \"CZ\", \"PT\", \"SB\"];\nexport const getPolishDayName = (date) => {\n\tlet dt = new Date(date);\n\treturn days_PL[dt.getDay()];\n}\n\nexport const timeValidator = (time) => {\n\tlet reg = /^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/;\n\treturn reg.test(time);\n}\n\nexport const shiftValidator = (shift) => {\n\tlet shifts = [\"1\", \"2\", \"3\", \"W\", \"PN\", \"WT\", \"ŚR\", \"CZ\", \"PT\", \"SB\", \"ND\"];\n\treturn shifts.includes(shift)\n}\n\n\n// Working same as Array.prototype.filter, but it's cut filtered elements from orginal array if they satisfy condition in predication\nexport const select = (arr, predicate) => {\n    if (typeof predicate != \"function\")\n      \tthrow new TypeError();\n\n    var selected = arr.filter( x => {\n\t\treturn (predicate.call(arr[0], x, arr))\n\t})\n\n\tfor ( const val of selected ) {\n\t\tlet i = arr.indexOf( val )\n\t\tarr.splice(i,1)\n\t}\n\n    return selected;\n};\n\n// Chunks the array into parts\nexport const chunk = (arr, size) => Array.from(\n\t{ length: Math.ceil(arr.length / size) },\n\t(v, i) => arr.slice(i * size, i * size + size)\n);\n\nexport const wodge = (arr, size) => Array.from(\n  { length: Math.ceil(arr.length / size) },\n  (v, i) => arr.slice(i * size, i * size + size + 1 )\n);\n\n// Copies arrays without any references\nexport const duplicate = (arr) => { return JSON.parse(JSON.stringify(arr)) };\n"]},"metadata":{},"sourceType":"module"}